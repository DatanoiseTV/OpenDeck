/*

Copyright 2015-2022 Igor Petrovic

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

#pragma once

namespace Board::detail::map
{
#ifdef ADC_SUPPORTED
            constexpr uint32_t adcChannel(uint8_t index)
            {
                return detail::map::adcChannel(A_IN_PINS[index]);
            }

            constexpr const core::io::mcuPin_t& adcPin(uint8_t index)
            {
                return A_IN_PINS[index];
            }

            constexpr uint8_t adcIndex(uint8_t index)
            {
#ifndef ANALOG_INDEXING
                return index;
#else
                return ANALOG_INDEXES[index];
#endif
            }
#endif

#if defined(NATIVE_BUTTON_INPUTS) || (defined(NUMBER_OF_BUTTON_ROWS) && !defined(NUMBER_OF_IN_SR))
            constexpr const core::io::mcuPin_t& buttonPin(uint8_t index)
            {
                return D_IN_PINS[index];
            }
#endif

#if defined(NATIVE_BUTTON_INPUTS)
            constexpr const core::io::pinPort_t digitalInPort(uint8_t index)
            {
                return D_IN_PORTS[index];
            }

            constexpr const uint8_t buttonPortIndex(uint8_t index)
            {
                return BUTTON_INDEX_TO_UNIQUE_PORT_INDEX[index];
            }

            constexpr const uint8_t buttonPinIndex(uint8_t index)
            {
                return BUTTON_INDEX_TO_PIN_INDEX[index];
            }
#endif

            constexpr uint8_t buttonIndex(uint8_t index)
            {
#ifndef BUTTON_INDEXING
                return index;
#else
                return BUTTON_INDEXES[index];
#endif
            }

#if defined(NATIVE_LED_OUTPUTS) || defined(NUMBER_OF_LED_ROWS)
            constexpr const core::io::mcuPin_t& ledPin(uint8_t index)
            {
                return D_OUT_PINS[index];
            }
#endif

#if defined(NATIVE_LED_OUTPUTS)
            constexpr const core::io::pinPort_t digitalOutPort(uint8_t index)
            {
                return D_OUT_PORTS[index];
            }

            constexpr const core::io::portWidth_t digitalOutPortClearMask(uint8_t index)
            {
                return D_OUT_PORTS_CLEAR_MASK[index];
            }

            constexpr const uint8_t ledPortIndex(uint8_t index)
            {
                return LED_INDEX_TO_UNIQUE_PORT_INDEX[index];
            }

            constexpr const uint8_t ledPinIndex(uint8_t index)
            {
                return LED_INDEX_TO_PIN_INDEX[index];
            }
#endif

            constexpr uint8_t ledIndex(uint8_t index)
            {
#ifndef LED_INDEXING
                return index;
#else
                return LED_INDEXES[index];
#endif
            }

#ifdef TOTAL_UNUSED_IO
            constexpr const Board::detail::IO::unusedIO_t& unusedPin(uint8_t index)
            {
                return UNUSED_PINS[index];
            }
#endif

#ifndef FLASH_PAGE_SIZE_COMMON
            constexpr const Board::detail::flash::flashPage_t& flashPageDescriptor(size_t pageIndex)
#else
            constexpr Board::detail::flash::flashPage_t flashPageDescriptor(size_t pageIndex)
#endif
            {
#ifdef FLASH_PAGE_SIZE_COMMON
                // calculate address only

                Board::detail::flash::flashPage_t descriptor = {};

                auto address    = FLASH_PAGE_ADDRESS(pageIndex);
                descriptor.size = FLASH_PAGE_SIZE_COMMON;

                if (address > FLASH_END)
                {
                    descriptor.address = 0;
                }
                else
                {
                    descriptor.address = address;
                }

                return descriptor;
#else
                if (pageIndex >= TOTAL_FLASH_PAGES)
                {
                    return PAGE_DESCRIPTOR[TOTAL_FLASH_PAGES - 1];
                }

                return PAGE_DESCRIPTOR[pageIndex];
#endif
            }

#ifdef CUSTOM_PERIPHERAL_PINS
#ifdef UART_SUPPORTED
            constexpr const Board::detail::UART::uartPins_t& uartPins(size_t channel)
            {
                return UART_PINS[channel];
            }
#endif

#ifdef I2C_SUPPORTED
            constexpr const Board::detail::I2C::i2cPins_t& i2cPins(size_t channel)
            {
                return I2C_PINS[channel];
            }
#endif
#endif
}    // namespace Board::detail::map